const mongoose = require('mongoose');

const appointmentSchema = new mongoose.Schema({
  // Referencia al negocio
  businessId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Business',
    required: true
  },
  
  // Información del cliente
  clientName: {
    type: String,
    required: true
  },
  clientPhone: {
    type: String,
    required: true
  },
  clientEmail: String,
  
  // Detalles de la cita
  service: {
    type: String,
    required: true
  },
  dateTime: {
    type: Date,
    required: true
  },
  duration: {
    type: Number,  // minutos
    default: 30
  },
  
  // Estado de la cita
  status: {
    type: String,
    enum: ['pending', 'confirmed', 'completed', 'cancelled', 'no-show', 'rescheduled'],
    default: 'pending'
  },
  
  // Notas
  notes: String,
  internalNotes: String,  // Solo visible para el negocio
  
  // Sistema de pagos (PREMIUM)
  payment: {
    required: { type: Boolean, default: false },
    amount: { type: Number, default: 0 },
    currency: { type: String, default: 'MXN' },
    status: {
      type: String,
      enum: ['pending', 'paid', 'partial', 'refunded', 'failed', 'not-required'],
      default: 'not-required'
    },
    method: {
      type: String,
      enum: ['cash', 'card', 'transfer', 'stripe', 'mercadopago', 'paypal', 'none'],
      default: 'none'
    },
    
    // Información de la transacción
    transactionId: String,
    paymentDate: Date,
    paymentLink: String,  // Link de pago generado
    
    // Detalles del pago
    depositRequired: { type: Boolean, default: false },
    depositAmount: Number,
    depositPaid: { type: Boolean, default: false },
    
    // Facturación
    invoiceRequired: { type: Boolean, default: false },
    invoiceData: {
      rfc: String,
      businessName: String,
      address: String,
      email: String
    },
    invoiceGenerated: { type: Boolean, default: false },
    invoiceUrl: String
  },
  
  // Recordatorios
  reminders: {
    sent24h: { type: Boolean, default: false },
    sent1h: { type: Boolean, default: false },
    emailSent: { type: Boolean, default: false }
  },
  
  // Historial de cambios
  history: [{
    action: String,  // 'created', 'confirmed', 'rescheduled', 'cancelled', etc.
    date: { type: Date, default: Date.now },
    note: String,
    performedBy: String  // 'client', 'business', 'system'
  }],
  
  // Reprogramación
  rescheduledFrom: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Appointment'
  },
  rescheduledTo: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Appointment'
  },
  
  // Metadata
  source: {
    type: String,
    enum: ['whatsapp', 'web', 'phone', 'walk-in', 'admin'],
    default: 'whatsapp'
  },
  
  // Confirmación
  confirmationCode: String,
  confirmedAt: Date,
  
  // Cancelación
  cancellationReason: String,
  cancelledAt: Date,
  cancelledBy: {
    type: String,
    enum: ['client', 'business', 'system']
  },
  
  // Rating/Feedback (después de completar)
  feedback: {
    rating: { type: Number, min: 1, max: 5 },
    comment: String,
    submittedAt: Date
  }
  
}, {
  timestamps: true
});

// Índices para mejorar performance
appointmentSchema.index({ businessId: 1, dateTime: 1 });
appointmentSchema.index({ clientPhone: 1 });
appointmentSchema.index({ status: 1 });
appointmentSchema.index({ 'payment.status': 1 });

// Virtual para saber si la cita está próxima
appointmentSchema.virtual('isUpcoming').get(function() {
  return this.dateTime > new Date() && ['pending', 'confirmed'].includes(this.status);
});

// Virtual para saber si está vencida
appointmentSchema.virtual('isPast').get(function() {
  return this.dateTime < new Date();
});

// Método para confirmar cita
appointmentSchema.methods.confirm = async function() {
  this.status = 'confirmed';
  this.confirmedAt = new Date();
  this.history.push({
    action: 'confirmed',
    performedBy: 'client',
    note: 'Cita confirmada por el cliente'
  });
  return await this.save();
};

// Método para cancelar cita
appointmentSchema.methods.cancel = async function(reason, cancelledBy = 'client') {
  this.status = 'cancelled';
  this.cancellationReason = reason;
  this.cancelledAt = new Date();
  this.cancelledBy = cancelledBy;
  this.history.push({
    action: 'cancelled',
    performedBy: cancelledBy,
    note: reason
  });
  
  // Si había pago, marcar para reembolso
  if (this.payment.status === 'paid') {
    this.payment.status = 'refunded';
  }
  
  return await this.save();
};

// Método para completar cita
appointmentSchema.methods.complete = async function() {
  this.status = 'completed';
  this.history.push({
    action: 'completed',
    performedBy: 'business',
    note: 'Cita completada'
  });
  return await this.save();
};

// Método para registrar pago
appointmentSchema.methods.registerPayment = async function(paymentData) {
  this.payment.status = 'paid';
  this.payment.method = paymentData.method;
  this.payment.transactionId = paymentData.transactionId;
  this.payment.paymentDate = new Date();
  
  this.history.push({
    action: 'payment_received',
    performedBy: 'system',
    note: `Pago recibido: ${paymentData.method} - ${this.payment.amount} ${this.payment.currency}`
  });
  
  return await this.save();
};

// Método para generar código de confirmación
appointmentSchema.methods.generateConfirmationCode = function() {
  this.confirmationCode = Math.random().toString(36).substring(2, 8).toUpperCase();
  return this.confirmationCode;
};

// Middleware para actualizar estadísticas del negocio
appointmentSchema.post('save', async function(doc) {
  const Business = mongoose.model('Business');
  const business = await Business.findById(doc.businessId);
  
  if (!business) return;
  
  // Actualizar contador de citas
  const Appointment = mongoose.model('Appointment');
  const stats = await Appointment.aggregate([
    { $match: { businessId: doc.businessId } },
    {
      $group: {
        _id: null,
        total: { $sum: 1 },
        completed: {
          $sum: { $cond: [{ $eq: ['$status', 'completed'] }, 1, 0] }
        },
        cancelled: {
          $sum: { $cond: [{ $eq: ['$status', 'cancelled'] }, 1, 0] }
        },
        totalRevenue: {
          $sum: {
            $cond: [
              { $eq: ['$payment.status', 'paid'] },
              '$payment.amount',
              0
            ]
          }
        }
      }
    }
  ]);
  
  if (stats.length > 0) {
    business.statistics.totalAppointments = stats[0].total;
    business.statistics.completedAppointments = stats[0].completed;
    business.statistics.cancelledAppointments = stats[0].cancelled;
    business.statistics.totalRevenue = stats[0].totalRevenue;
    business.statistics.lastRevenueUpdate = new Date();
    await business.save();
  }
});

// Middleware para validar horarios de negocio
appointmentSchema.pre('save', async function(next) {
  if (this.isNew || this.isModified('dateTime')) {
    const Business = mongoose.model('Business');
    const business = await Business.findById(this.businessId);
    
    if (!business) {
      return next(new Error('Negocio no encontrado'));
    }
    
    const appointmentDate = new Date(this.dateTime);
    const dayOfWeek = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'][appointmentDate.getDay()];
    const businessHours = business.businessHours[dayOfWeek];
    
    if (!businessHours || !businessHours.active) {
      return next(new Error(`El negocio no está disponible los ${dayOfWeek}`));
    }
    
    // Validar que la hora esté dentro del horario
    const appointmentTime = appointmentDate.getHours() * 60 + appointmentDate.getMinutes();
    const [openHour, openMin] = businessHours.open.split(':').map(Number);
    const [closeHour, closeMin] = businessHours.close.split(':').map(Number);
    const openTime = openHour * 60 + openMin;
    const closeTime = closeHour * 60 + closeMin;
    
    if (appointmentTime < openTime || appointmentTime >= closeTime) {
      return next(new Error('La hora seleccionada está fuera del horario de atención'));
    }
  }
  
  next();
});

module.exports = mongoose.model('Appointment', appointmentSchema);const mongoose = require('mongoose');

const appointmentSchema = new mongoose.Schema({
  businessId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Business',
    required: true
  },
  
  patient: {
    name: { type: String, required: true },
    phone: { type: String, required: true },
    email: String
  },
  
  service: { type: String, required: true },
  datetime: { type: Date, required: true },
  duration: { type: Number, default: 60 },
  
  status: {
    type: String,
    enum: ['pendiente', 'confirmada', 'en-curso', 'completada', 'retrasada', 'cancelada'],
    default: 'confirmada'
  },
  
  delay: { type: Number, default: 0 },
  
  reminders: {
    sent24h: { type: Boolean, default: false },
    sent1h: { type: Boolean, default: false },
    sent10min: { type: Boolean, default: false }
  },
  
  source: {
    type: String,
    enum: ['whatsapp', 'phone', 'web', 'walk-in'],
    default: 'whatsapp'
  },
  
  notes: String
}, { 
  timestamps: true 
});

appointmentSchema.index({ businessId: 1, datetime: 1 });
appointmentSchema.index({ 'patient.phone': 1 });
appointmentSchema.index({ status: 1, datetime: 1 });

module.exports = mongoose.model('Appointment', appointmentSchema);
